import json
import sys
import os

# Add the subdirectory to the Python path to find the modules. This is the most
# reliable way to ensure that scripts within the subfolder can also find each other.
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'TEST_GEN_subscripts'))
from exhaustive_list_gen import run_exhaustive_generator
from atpg_tester_v2 import run_d_algorithm_atpg

# ----- CONFIGURATION -----
LOGIC_INPUT_LIMIT = 10  
# -------------------------

def get_num_inputs(netlist_file_path):
    """A helper function to quickly parse a netlist and count primary inputs."""
    try:
        with open(netlist_file_path, 'r') as f:
            data = json.load(f)
        
        # Try to access the netlist structure as generated by verilog_to_netlist.py
        # which has the module name as the top-level key.
        module_name = list(data.keys())[0]
        ports = data[module_name]['ports']

        num_inputs = sum(1 for port in ports.values() if port.get('direction') == 'Input')
        return num_inputs
    except (FileNotFoundError, IndexError, KeyError) as e:
        # This will catch errors if the file is missing, empty, or has an unexpected structure.
        print(f"Debug: Encountered an error in get_num_inputs - {e}")
        return -1 # Return an error code

def main():
    """Main controller to decide which testing strategy to use."""
    if len(sys.argv) != 3:
        # --- MODIFIED: Updated usage message ---
        print("Usage: python test_vector_list_gen.py <netlist.json> <fault_list.json>")
        sys.exit(1)
        
    # Construct full paths for input files from dedicated directories
    netlist_file = os.path.join("NETLISTS", sys.argv[1])
    fault_list_file = os.path.join("FAULT_LISTS", sys.argv[2])

    num_inputs = get_num_inputs(netlist_file)

    if num_inputs == -1:
        print(f"Error: Could not determine number of inputs from '{netlist_file}'.")
        sys.exit(1)
        
    # Define the output directory and the original working directory
    output_dir = "TEST_VECTOR_RESULTS"
    original_cwd = os.getcwd()

    print(f"Circuit has {num_inputs} inputs. The limit is {LOGIC_INPUT_LIMIT}.")

    # --- The Core Decision Logic ---
    if num_inputs <= LOGIC_INPUT_LIMIT:
        print("--> Input count is within the limit. Using exhaustive vector generator.")
        # Temporarily change directory to write the output file, then change back
        try:
            os.chdir(output_dir)
            # Use absolute path for input since we changed directory
            abs_netlist_path = os.path.join(original_cwd, netlist_file)
            run_exhaustive_generator(abs_netlist_path)
        finally:
            os.chdir(original_cwd) # Ensure we always return to the original directory
    else:
        print("--> Input count exceeds the limit. Using D-Algorithm ATPG.")
        # Temporarily change directory to write the output file, then change back
        try:
            os.chdir(output_dir)
            # Use absolute paths for inputs since we changed directory
            abs_netlist_path = os.path.join(original_cwd, netlist_file)
            abs_fault_list_path = os.path.join(original_cwd, fault_list_file)
            run_d_algorithm_atpg(abs_netlist_path, abs_fault_list_path)
        finally:
            os.chdir(original_cwd) # Ensure we always return to the original directory

if __name__ == "__main__":
    main()
