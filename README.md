**IGNORE THE delete FOLDER COMPLETELY**

**WARNING**

No script should use any Unicode extended character in ANY output (terminal output or file write). Use only ASCII characters in output.

**FILE ORGANIZATION**

FAULT_LISTS - Directory to store all collapsed fault list JSON files
              File Naming Convention - fault_list_[VERILOG DIRECTORY NAME].json

FAULT_STATISTICS - Directory to store final fault statistics result
                   File Naming Convention - fault_statistics_[VERILOG DIRECTORY NAME].txt

NETLISTS - Directory to store flattened netlist JSON files
           File Naming Convention - netlist_[VERILOG DIRECTORY NAME].json

TEST_DESIGNS - Directory to store Verilog design folders. 
               Verilog design folders have no fixed naming convention.

USER_TEST_VECTORS - Directory to store test vectors defined in Verilog format specified by user in .txt files. 
                    .txt files have no fixed naming convention.
                    CONSTRAINT - In case of multibit input ports, user must specify the values from LSB to MSB.

**NETLIST GENERATION SCRIPTS**

verilog_to_netlist.py --> Netlist generator. Takes path to design folder as input. Folder must have exactly one .v file named as "combinatorial_[integer].v" . This first module inside this file is treated as the top module. Generates a new "all_modules.v" file inside design folder containing all unique module definitions (if all_modules.v already exists, it will rename file as "all_modules[integer].v"). Generates flattened netlist named "netlist_[design_folder_name].json" inside NETLISTS subfolder. Supported Verilog primitives : and,or,nand,nor,xor,xnor,buf,not,bufif1,bufif0,notif1,notif0

Netlist JSON will be generated and reside inside NETLISTS folder. JSON file naming convention (generated by verilog_to_netlist.py) : netlist_[INTEGER].json

**FAULT LIST GENERATION SCRIPTS**

fault_list_gen.py --> considers PI and fanout only and uses checkpoint theorem to generate fault list (stores fault list in FAULT_LISTS subfolder
Fault list JSON file will be generated and reside inside FAULT_LISTS subfolder naming convention (generated by fault_list_gen.py) : fault_list_comb_[INTEGER].json

**LOGIC EVALUATOR AND CHECKER SCRIPTS**

logic_evaluator.py --> computation done by compute() function. Tester should invoke this function. Needs two parameters : a list of operand words (strings of any length) and a string mentioning the operation (and,or,not,buf,notif1,notif0,bufif1,bufif0,nand,nor,xor,xnor). For tristate gates, exactly two input words : first word is input, second word is control.

logic_eval_checker.py --> invokes logic_evaluator.py, checks for all single input, 2 input and 3 input gates for all possible combinations of 3 bit word length vectors. The exhaustive test results are written into a .txt file which is > 100MB, hence I will attach [google drive link](https://drive.google.com/drive/folders/1hZVgVDqM7l2cUY0yMfNnMxIHhtbDwZEr?usp=sharing)
Default Mode (Terminal Summary Only)
Running python **logic_evaluator_tester.py** without arguments executes all 1.6 million tests and prints only the final summary to the terminal without creating any files.
File Writing Mode
Running python **logic_evaluator_tester.py write** executes all tests and creates a timestamped text file containing detailed results for every test case, while also printing the summary to the terminal.

**TEST VECTOR GENERATION SCRIPTS**

test_vector_list_gen.py --> the top module to create test vectors. Takes a  netlist_[INTEGER].json AUTOMATICALLY FROM NETLISTS SUBFOLDER and fault_list_comb_[INTEGER] from the AUTOMATICALLY FROM FAULT_LISTS SUBFOLDER as input and produces test_vector_[INTEGER].txt INSIDE THE SUBFOLDER NAMED TEST_VECTOR_RESULTS. It has a LOGIC_INPUT_LIMIT, if the netlist has less inouts than that it uses **exhaustive_list_gen.py** to create a exhasutive fault list, else it wil use **atpg_tester_v2.py(which calls d_algorithm_atpg.py)** to create test vector curated for each fault in the fault list.

exhaustive_list_gen.py  --> generates all possible test vectors --> to be called from test_vector_list_gen.
atpg_tester_v2.py  --> modified version of atpg_tester.py just to be called from test_vector_list_gen.

**ALL DEPENDENCIES OF THE TOP MODULES ARE STORED IN A SUBFOLDR CALLED TEST_GEN_subscripts ( ALL PATH MANAGED)**

**VERILOG STYLE INPUT TO NETLIST PORT MAPPING**

python vector_to_netlist_mapper.py **netlist_7.json A=10011001 B=11001100 CIN=1**
--- Input Vector to Netlist Port Mapping ---
Original Verilog-style inputs:
{
    "A": "10011001",
    "B": "11001100",
    "CIN": "1"
}
Mapped to scalar netlist ports (Console Output):
{
    "A0": "1",
    "A1": "0",
    "A2": "0",
    "A3": "1",
    "A4": "1",
    "A5": "0",
    "A6": "0",
    "A7": "1",
    "B0": "0",
    "B1": "0",
    "B2": "1",
    "B3": "1",
    "B4": "0",
    "B5": "0",
    "B6": "1",
    "B7": "1",
    "CIN": "1"
}
Successfully generated mapping report at: 'MAPPING_REPORTS\mapping_report_netlist_7.txt'
Script must return the complete path to the .txt file containing the unpacked test vectors.

**SIMULATOR** 

simulator.py --> contains function simulate(). Do not run simulator.py directly. Import simulate() function and run that instead. simulate() takes three arguments - path to netlist JSON file, input word list (list of strings) and stuck-at fault, specified as a string in this format : "[net_name]:[fault_value]". If no fault is to be injected, this argument is set to None. Function returns output words in dict format. {[output_port_name] : "output_word"}. Refer to simulator_test.py for example usage. 

NOTE : Simulator supports 4-value logic (0,1,x,z). x and z must be specified in lowercase. Uppercase X and Z will cause errors.

**FAULT STATISTICS GENERATOR**

generate_fault_statistics.py --> Frontend script invoked by the user, performs parallel fault simulation and generates fault statistics report in FAULT_STATISTICS folder. 
Usage : python generate_fault_statistics.py [path to Verilog folder] [path to .txt file containing user defined input vectors] [OPTIONAL][parallel simulation word length]
If not specified by user, default parallel simulation word length is 4.
