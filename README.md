Verilog file naming convention: combinatorial_<INTEGER>.v

Netlist JSON file naming convention (generated by verilog_to_netlist.py) : netlist_<INTEGER>.json

Fault list JSON file naming convention (generated by fault_list_gen.py or fault_list_gen_v2.py) : fault_list_comb_<INTEGER>.json

verilog_to_netlist.py --> Netlist generator. Takes path to design folder as input. Folder must have exactly one .v file named as "combinatorial_<integer>.v" . This first module inside this file is treated as the top module. Generates flattened netlist named "netlist_<integer>.json". Supported Verilog primitives : and,or,nand,nor,xor,xnor,buf,not,bufif1,bufif0,notif1,notif0

fault_list_gen.py --> considers PI and fanout only

fault_list_gen_v2.py --> considers PI,PO and fanout only

logic_evaluator.py --> computation done by compute() function. Tester should invoke this function. Needs two parameters : a list of operand words (strings of any length) and a string mentioning the operation (and,or,not,buf,notif1,notif0,bufif1,bufif0,nand,nor,xor,xnor). For tristate gates, exactly two input words : first word is input, second word is control.

logic_eval_checker.py --> invokes logic_evaluator.py, checks for all single input, 2 input and 3 input gates for all possible combinations of 3 bit word length vectors
The exhaustive test results are written into a .txt file which is > 100MB, hence I will attach [google drive link](https://drive.google.com/drive/folders/1hZVgVDqM7l2cUY0yMfNnMxIHhtbDwZEr?usp=sharing)
Default Mode (Terminal Summary Only)
Running python **logic_evaluator_tester.py** without arguments executes all 1.6 million tests and prints only the final summary to the terminal without creating any files.
File Writing Mode
Running python **logic_evaluator_tester.py write** executes all tests and creates a timestamped text file containing detailed results for every test case, while also printing the summary to the terminal.


test_vector_gen_v1.py  --> simply takes the JSON netlist file, counts the number of n inputs to the circuit and then creates a test vector file having all possible 2^n combinations for n bits.

Use the atpg_tester.py --> which calls the d_algorithm_atpg.py file and takes a json netlist as input and generates test vectors for all faults in the fault_list_comb json and dumps into a atpg_results txt file

test_vector_list_gen.py --> the top module to create test vectors. Takes a netlist.json and fault_list.json as input and produces test_vector.txt. It has a LOGIC_INPUT_LIMIT, if the netlist has less inouts than that it uses exhaustive_list_gen.py to create a exhasutive fault list, else it wil use atpg_tester_v2.py to create test vector curated for each fault in the fault list.

exhaustive_list_gen.py  --> modified version of test_vector_gen_v1.py just to be called from test_vector_list_gen.

atpg_tester_v2.py  --> modified version of atpg_tester.py just to be called from test_vector_list_gen.
