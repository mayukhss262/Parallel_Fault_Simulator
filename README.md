Verilog file naming convention: combinatorial_<INTEGER>.v

Netlist JSON file naming convention (generated by verilog_to_netlist.py) : netlist_<INTEGER>.json

Fault list JSON file naming convention (generated by fault_list_gen.py or fault_list_gen_v2.py) : fault_list_comb_<INTEGER>.json

fault_list_gen.py --> considers PI and fanout only

fault_list_gen_v2.py --> considers PI,PO and fanout only

logic_evaluator.py --> computation done by compute() function. Tester should invoke this function. Needs two parameters : a list of operand words (strings of any length) and a string mentioning the operation (and,or,not,buf,notif1,notif0,bufif1,bufif0,nand,nor,xor,xnor). For tristate gates, exactly two input words : first word is input, second word is control.

logic_eval_checker.py --> invokes logic_evaluator.py, checks for all single input, 2 input and 3 input gates for all possible combinations of 3 bit word length vectors
The exhaustive test results are written into a .txt file which is > 100MB, hence I will attach [google drive link](https://drive.google.com/drive/folders/1hZVgVDqM7l2cUY0yMfNnMxIHhtbDwZEr?usp=sharing)
Default Mode (Terminal Summary Only)
Running python **logic_evaluator_tester.py** without arguments executes all 1.6 million tests and prints only the final summary to the terminal without creating any files.
File Writing Mode
Running python **logic_evaluator_tester.py write** executes all tests and creates a timestamped text file containing detailed results for every test case, while also printing the summary to the terminal.


test_vector_gen_v1.py  --> simply takes the JSON netlist file, counts the number of n inputs to the circuit and then creates a test vector file having all possible 2^n combinations for n bits.

Use the atpg_tester.py --> which calls the d_algorithm_atpg.py file and takes a json netlist as input and generates test vectors for all faults in the fault_list_comb json and dumps into a atpg_results txt file
